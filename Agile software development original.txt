Agile software development 
In software development, agile (sometimes written Agile)[1] is a set of practices intended to improve the effectiveness of software development professionals, teams, and organizations. It involves discovering requirements and developing solutions through the collaborative effort of self-organizing and cross- functional teams and their customer(s)/end user(s).[2] It advocates adaptive planning, evolutionary development, early delivery, and continual improvement, and it encourages flexible responses to changes in requirements, resource availability, and understanding of the problems to be solved.[3][4] 
It was popularized by the 2001 Manifesto for Agile Software Development.[5] The values and principles exposed in this manifesto were derived from and underpin a broad range of software development frameworks, including Scrum and Kanban.[6][7] 
While there is much anecdotal evidence that adopting agile practices and values improves the effectiveness of software professionals, teams and organizations, the empirical evidence is mixed and hard to find.[8][9] 
History 
Iterative and incremental software development methods can be traced back as early as 1957,[10] with evolutionary project management[11][12] and adaptive software development[13] emerging in the early 1970s.[14] 
During the 1990s, a number of lightweight software development methods evolved in reaction to the prevailing heavyweight methods (often referred to collectively as waterfall) that critics described as overly regulated, planned, and micromanaged. These included: rapid application development (RAD), from 1991;[15][16] the unified process (UP) and dynamic systems development method (DSDM), both from 1994; Scrum, from 1995; Crystal Clear and extreme programming (XP), both from 1996; and feature- driven development, from 1997. Although these all originated before the publication of the Agile Manifesto, they are now collectively referred to as agile software development methods.[7] At the same time, similar changes were underway in manufacturing[17][18] and management thinking. 
In 2001, these seventeen software developers met at a resort in Snowbird, Utah to discuss these lightweight development methods: Kent Beck, Ward Cunningham, Dave Thomas, Jeff Sutherland, Ken Schwaber, Jim Highsmith, Alistair Cockburn, Robert C. Martin, Mike Beedle, Arie van Bennekum, Martin Fowler, James Grenning, Andrew Hunt, Ron Jeffries, Jon Kern, Brian Marick, and Steve Mellor. Together they published the Manifesto for Agile Software Development.[5] 
In 2005, a group headed by Cockburn and Highsmith wrote an addendum of project management principles, the PM Declaration of Interdependence,[19] to guide software project management according to agile software development methods. 
In 2009, a group working with Martin wrote an extension of software development principles, the Software Craftsmanship Manifesto, to guide agile software development according to professional conduct and mastery. 
In 2011, the Agile Alliance created the Guide to Agile Practices (renamed the Agile Glossary in 2016),[20] an evolving open-source compendium of the working definitions of agile practices, terms, and elements, along with interpretations and experience guidelines from the worldwide community of agile practitioners. 
The Manifesto for Agile Software Development 
Agile software development values 
Based on their combined experience of developing software and helping others do that, the seventeen signatories to the manifesto proclaimed that they value:[5] 
Individuals and interactions over processes and tools 
Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan 
That is to say, the items on the left are valued more than the items on the right. It is not to say that the items on the right should be excluded in favor of the items on the left. Both sides have value, but from an Agile Development point of view the authors of the manifesto tip the balance in favor of the items on the left. 
As Scott Ambler elucidated:[21] 
Tools and processes are important, but it is more important to have competent people working together effectively. 
Good documentation is useful in helping people to understand how the software is built and how to use it, but the main point of development is to create software, not documentation. 
A contract is important but is no substitute for working closely with customers to discover what they need. 
A project plan is important, but it must not be too rigid to accommodate changes in technology or the environment, stakeholders' priorities, and people's understanding of the problem and its solution. 
Some of the authors formed the Agile Alliance, a non-profit organization that promotes software development according to the manifesto's values and principles. Introducing the manifesto on behalf of the Agile Alliance, Jim Highsmith said, 
The Agile movement is not anti-methodology, in fact many of us want to restore credibility to the word methodology. We want to restore a balance. We embrace modeling, but not in order to file some diagram in a dusty corporate repository. We embrace documentation, but not hundreds of pages of never-maintained and rarely-used tomes. We plan, but recognize the limits of planning in a turbulent environment. Those who would brand proponents of XP or SCRUM or any of the other Agile Methodologies as "hackers" are ignorant of both the methodologies and the original definition of the term hacker. 
— Jim Highsmith, History: The Agile Manifesto[22] 
Agile software development principles 
Agile software development principles 
The Manifesto for Agile Software Development is based on twelve principles:[23] 
1. Customer satisfaction by early and continuous delivery of valuable software. 2. Welcome changing requirements, even in late development.
3. Deliver working software frequently (weeks rather than months)
4. Close, daily cooperation between business people and developers 
5. Projects are built around motivated individuals, who should be trusted
6. Face-to-face conversation is the best form of communication (co-location) 7. Working software is the primary measure of progress
8. Sustainable development, able to maintain a constant pace 
9. Continuous attention to technical excellence and good design
10. Simplicity—the art of maximizing the amount of work not done—is essential
11. Best architectures, requirements, and designs emerge from self-organizing teams
12. Regularly, the team reflects on how to become more effective, and adjusts accordingly 
Overview 
Iterative, incremental, and evolutionary 
Most agile development methods break product development work
into small increments that minimize the amount of up-front planning
and design. Iterations, or sprints, are short time frames (timeboxes)
that typically last from one to four weeks. Each iteration involves a
cross-functional team working in all functions: planning, analysis,
design, coding, unit testing, and acceptance testing. At the end of the
iteration a working product is demonstrated to stakeholders. This
minimizes overall risk and allows the product to adapt to changes
quickly.[24] An iteration might not add enough functionality to
warrant a market release, but the goal is to have an available release
(with minimal bugs) at the end of each iteration.[25] Through incremental development products have room to "fail often and early" throughout each iterative phase instead of drastically on a final release date.[26] Multiple iterations might be required to release a product or new features. Working software is the primary measure of progress.[23] 
Efficient and face-to-face communication 
The principle of co-location is that co-workers on the same team should be situated together to better establish the identity as a team and to improve communication.[27] This enables face-to-face interaction, ideally in front of a whiteboard, that reduces the cycle time typically taken when questions and answers are mediated through phone, persistent chat, wiki, or email.[28] 
No matter which development method is followed, every team should include a customer representative ("Product Owner" in Scrum). This person is agreed by stakeholders to act on their behalf and makes a personal commitment to being available for developers to answer questions throughout the iteration. At the end of each iteration, stakeholders and the customer representative review progress and re-evaluate priorities with a view to optimizing the return on investment (ROI) and ensuring alignment with customer needs and company goals. The importance of stakeholder satisfaction, detailed by frequent interaction and review at the end of each phase, is why the methodology is often denoted as a "Customer Centered Methodology".[29] 
In agile software development, an information radiator is a (normally large) physical display located prominently near the development team, where passers-by can see it. It presents an up-to-date summary of the product development status.[30][31] A build light indicator may also be used to inform a team about the current status of their product development. 
Very short feedback loop and adaptation cycle 
A common characteristic in agile software development is the daily stand-up (a daily scrum in Scrum framework). In a brief session, team members report to each other what they did the previous day toward their team's iteration goal, what they intend to do today toward the goal, and any roadblocks or impediments they can see to the goal.[32] 
Quality focus 
Specific tools and techniques, such as continuous integration, automated unit testing, pair programming, test-driven development, design patterns, behavior-driven development, domain-driven design, code refactoring and other techniques are often used to improve quality and enhance product development agility.[33] This is predicated on designing and building quality in from the beginning and being able to demonstrate software for customers at any point, or at least at the end of every iteration.[34] 
Philosophy 
Compared to traditional software engineering, agile software development mainly targets complex systems and product development with dynamic, non-deterministic and non-linear characteristics. Accurate estimates, stable plans, and predictions are often hard to get in early stages, and confidence in them is likely to be low. Agile practitioners will seek to reduce the leap-of-faith that is needed before any evidence of value can be obtained.[35] Requirements and design are held to be emergent. Big up-front specifications would probably cause a lot of waste in such cases, i.e., are not economically sound. These basic arguments and previous industry experiences, learned from years of successes and failures, have helped shape agile development's favor of adaptive, iterative and evolutionary development.[36] 
Adaptive vs. predictive 
Development methods exist on a continuum from adaptive to predictive.[37] Agile software development methods lie on the adaptive side of this continuum. One key of adaptive development methods is a rolling wave approach to schedule planning, which identifies milestones but leaves flexibility in the path to reach them, and also allows for the milestones themselves to change.[38] 
Adaptive methods focus on adapting quickly to changing realities. When the needs of a project change, an adaptive team changes as well. An adaptive team has difficulty describing exactly what will happen in the future. The further away a date is, the more vague an adaptive method is about what will happen on that date. An adaptive team cannot report exactly what tasks they will do next week, but only which features they plan for next month. When asked about a release six months from now, an adaptive team might be able to report only the mission statement for the release, or a statement of expected value vs. cost. 
Predictive methods, in contrast, focus on analysing and planning the future in detail and cater for known risks. In the extremes, a predictive team can report exactly what features and tasks are planned for the entire length of the development process. Predictive methods rely on effective early phase analysis and if this goes very wrong, the project may have difficulty changing direction. Predictive teams often institute a change control board to ensure they consider only the most valuable changes. 
Risk analysis can be used to choose between adaptive (agile or value-driven) and predictive (plan-driven) methods.[39] Barry Boehm and Richard Turner suggest that each side of the continuum has its own home ground, as follows:[40] 
Agile vs. waterfall 
Home grounds of different development methods 
Plan-driven methods 
High criticality 
Junior developers(?) 
Requirements do not change often 
Large number of developers 
Culture that demands order 
Formal methods 
Extreme criticality 
Senior developers 
Limited requirements, limited features see Wirth's law 
Requirements that can be modeled 
Extreme quality 
         
One of the differences between agile software development methods and waterfall is the approach to quality and testing. In the waterfall model, work moves through Software Development Lifecycle (SDLC) phases—with one phase being completed before another can start—hence the testing phase is separate and follows a build phase. In agile software development, however, testing is completed in the same iteration as programming. Another way of looking at it is “Agile: make it up as you go along. Waterfall: make it up before you start, live with the consequences”. [41] 
Because testing is done in every iteration—which develops a small piece of the software—users can frequently use those new pieces of software and validate the value. After the users know the real value of the updated piece of software, they can make better decisions about the software's future. Having a value retrospective and software re-planning session in each iteration—Scrum typically has iterations of just two weeks—helps the team continuously adapt its plans so as to maximize the value it delivers. This follows a pattern similar to the Plan-Do-Check-Act (PDCA) cycle, as the work is planned, done, checked (in the review and retrospective), and any changes agreed are acted upon. 
This iterative approach supports a product rather than a project mindset. This provides greater flexibility throughout the development process; whereas on projects the requirements are defined and locked down from the very beginning, making it difficult to change them later. Iterative product development allows the software to evolve in response to changes in business environment or market requirements. 
Code vs. documentation 
In a letter to IEEE Computer, Steven Rakitin expressed cynicism about agile software development, calling it "yet another attempt to undermine the discipline of software engineering" and translating "working software over comprehensive documentation" as "we want to spend all our time coding. Remember, real programmers don't write documentation."[42] 
This is disputed by proponents of agile software development, who state that developers should write documentation if that is the best way to achieve the relevant goals, but that there are often better ways to achieve those goals than writing static documentation.[43] Scott Ambler states that documentation should be "just barely good enough" (JBGE),[44] that too much or comprehensive documentation would usually cause waste, and developers rarely trust detailed documentation because it's usually out of sync with code,[43] while too little documentation may also cause problems for maintenance, communication, learning and knowledge sharing. Alistair Cockburn wrote of the Crystal Clear method: 
Crystal considers development a series of co-operative games, and intends that the documentation is enough to help the next win at the next game. The work products for Crystal include use cases, risk list, iteration plan, core domain models, and design notes to inform on choices...however there are no templates for these documents and descriptions are necessarily vague, but the objective is clear, just enough documentation for the next game. I always tend to characterize this to my team as: what would you want to know if you joined the team tomorrow. 
Agile software development methods 
Agile software development methods support a broad range of the software development life cycle.[46] Some methods focus on the practices (e.g., XP, pragmatic programming, agile modeling), while some focus on managing the flow of work (e.g., Scrum, Kanban). Some support activities for requirements specification and development (e.g., FDD), while some seek to cover the full development life cycle (e.g., DSDM, RUP). 
Method 
In the literature, different terms refer to the notion of method adaptation, including 'method tailoring', 'method fragment adaptation' and 'situational method engineering'. Method tailoring is defined as: 
A process or capability in which human agents determine a system development approach for a specific project situation through responsive changes in, and dynamic interplays between contexts, intentions, and method fragments. 
— Mehmet Nafiz Aydin et al., An Agile Information Systems Development Method in use[48] 
Situation-appropriateness should be considered as a distinguishing characteristic between agile methods and more plan-driven software development methods, with agile methods allowing product development teams to adapt working practices according to the needs of individual products.[49][48] Potentially, most agile 
methods could be suitable for method tailoring,[46] such as DSDM tailored in a CMM context.[50] and XP tailored with the Rule Description Practices (RDP) technique.[51] Not all agile proponents agree, however, with Schwaber noting "that is how we got into trouble in the first place, thinking that the problem was not having a perfect methodology. Efforts [should] center on the changes [needed] in the enterprise".[52] Bas Vodde reinforced this viewpoint, suggesting that unlike traditional, large methodologies that require you to pick and choose elements, Scrum provides the basics on top of which you add additional elements to localise and contextualise its use.[53] Practitioners seldom use system development methods, or agile methods specifically, by the book, often choosing to omit or tailor some of the practices of a method in order to create an in-house method.[54] 
In practice, methods can be tailored using various tools. Generic process modeling languages such as Unified Modeling Language can be used to tailor software development methods. However, dedicated tools for method engineering such as the Essence Theory of Software Engineering of SEMAT also exist.[55] 
Large-scale, offshore and distributed 
Agile software development has been widely seen as highly suited to certain types of environments, including small teams of experts working on greenfield projects,[40][56]:157 and the challenges and limitations encountered in the adoption of agile software development methods in a large organization with legacy infrastructure are well-documented and understood.[57] 
In response, a range of strategies and patterns has evolved for overcoming challenges with large-scale development efforts (>20 developers)[58][59] or distributed (non-colocated) development teams,[60][61] amongst other challenges; and there are now several recognised frameworks that seek to mitigate or avoid these challenges. 
Scaled agile framework (SAFe),[62] Dean Leffingwell et al Disciplined agile delivery (DAD), Scott Ambler et al Large-scale scrum (LeSS), Craig Larman and Bas Vodde Nexus (scaled professional Scrum),[63] Ken Schwaber Scrum at Scale,[64] Jeff Sutherland, Alex Brown Enterprise Scrum,[65] Mike Beedle 
Setchu (Scrum-based lightweight framework),[66] Michael Ebbage XSCALE[67]
Agile path[68] --
Holistic Software Development[69] 
There are many conflicting viewpoints on whether all of these are effective or indeed fit the definition of agile development, and this remains an active and ongoing area of research.[58][70] 
When agile software development is applied in a distributed setting (with teams dispersed across multiple business locations), it is commonly referred to as Distributed agile software development. The goal is to leverage the unique benefits offered by each approach. Distributed development allows organizations to build software by strategically setting up teams in different parts of the globe, virtually building software round-the-clock (more commonly referred to as follow-the-sun model). On the other hand, agile development provides increased transparency, continuous feedback, and more flexibility when responding to changes. 
Regulated domains 
Agile software development methods were initially seen as best suitable for non-critical product developments, thereby excluded from use in regulated domains such as medical devices, pharmaceutical, financial, nuclear systems, automotive, and avionics sectors, etc. However, in the last several years, there have been several initiatives for the adaptation of agile methods for these domains.[71][72][73][74][75] 
There are numerous standards that may apply in regulated domains, including ISO 26262, ISO 9000, ISO 9001, and ISO/IEC 15504. A number of key concerns are of particular importance in regulated domains:[76] 
Quality assurance (QA): Systematic and inherent quality management underpinning a controlled professional process and reliability and correctness of product. 
Safety and security: Formal planning and risk management to mitigate safety risks for users and securely protecting users from unintentional and malicious misuse. 
Traceability: Documentation providing auditable evidence of regulatory compliance and facilitating traceability and investigation of problems. 
Verification and Validation (V&V): Embedded throughout the software development process (e.g. user requirements specification, functional specification, design specification, code review, unit tests, integration tests, system tests). 
Experience and adoption 
Although agile software development methods can be used with any programming paradigm or language in practice, they were originally closely associated with object-oriented environments such as Smalltalk, Lisp and later Java, C#. The initial adopters of agile methods were usually small to medium-sized teams working on unprecedented systems with requirements that were difficult to finalize and likely to change as the system was being developed. This section describes common problems that organizations encounter when they try to adopt agile software development methods as well as various techniques to measure the quality and performance of agile teams.[77] 
Measuring agility Internal assessments 
The Agility measurement index, amongst others, rates developments against five dimensions of product development (duration, risk, novelty, effort, and interaction).[78][79] Other techniques are based on measurable goals[80] and one study suggests that velocity can be used as a metric of agility.[81] There are also agile self-assessments to determine whether a team is using agile software development practices (Nokia test,[82] Karlskrona test,[83] 42 points test).[84] 
Public surveys 
One of the early studies reporting gains in quality, productivity, and business satisfaction by using agile software developments methods was a survey conducted by Shine Technologies from November 2002 to January 2003.[85] 
A similar survey, the State of Agile, is conducted every year starting in 2006 with thousands of participants from around the software development community. This tracks trends on the perceived benefits of agility, lessons learned, and good practices. Each survey has reported increasing numbers saying that agile software development helps them deliver software faster; improves their ability to manage changing customer priorities; and increases their productivity.[86] Surveys have also consistently shown better results with agile product development methods compared to classical project management.[87][88] In balance, there are reports that some feel that agile development methods are still too young to enable extensive academic research of their success.[89] 
Common agile software development pitfalls 
Organizations and teams implementing agile software development often face difficulties transitioning from more traditional methods such as waterfall development, such as teams having an agile process forced on them.[90] These are often termed agile anti-patterns or more commonly agile smells. Below are some common examples: 
Lack of overall product design 
A goal of agile software development is to focus more on producing working software and less on documentation. This is in contrast to waterfall models where the process is often highly controlled and minor changes to the system require significant revision of supporting documentation. However, this does not justify completely doing without any analysis or design at all. Failure to pay attention to design can cause a team to proceed rapidly at first but then to have significant rework required as they attempt to scale up the system. One of the key features of agile software development is that it is iterative. When done correctly design emerges as the system is developed and commonalities and opportunities for re-use are discovered.[91] 
Adding stories to an iteration in progress 
In agile software development, stories (similar to use case descriptions) are typically used to define requirements and an iteration is a short period of time during which the team commits to specific goals.[92] Adding stories to an iteration in progress is detrimental to a good flow of work. These should be added to the product backlog and prioritized for a subsequent iteration or in rare cases the iteration could be cancelled.[93] 
This does not mean that a story cannot expand. Teams must deal with new information, which may produce additional tasks for a story. If the new information prevents the story from being completed during the iteration, then it should be carried over to a subsequent iteration. However, it should be prioritized against all remaining stories, as the new information may have changed the story's original priority. 
Lack of sponsor support 
Agile software development is often implemented as a grassroots effort in organizations by software development teams trying to optimize their development processes and ensure consistency in the software development life cycle. By not having sponsor support, teams may face difficulties and resistance from business partners, other development teams and management. Additionally, they may suffer without appropriate funding and resources.[94] This increases the likelihood of failure.[95] 
Insufficient training 
A survey performed by VersionOne found respondents cited insufficient training as the most significant cause for failed agile implementations[96] Teams have fallen into the trap of assuming the reduced processes of agile software development compared to other methodologies such as waterfall means that there are no actual rules for agile software development. 

